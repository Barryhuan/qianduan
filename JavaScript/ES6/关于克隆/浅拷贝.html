<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>浅拷贝</title>
	</head>
	<body>
		<script>
			// 浅拷贝（数组/对象）
			// 定义：浅拷贝不是赋值操作，是按位精确拷贝旧对象，创建一个新的对象，如果旧对象中的属性是基本数据类型，拷贝的就是基本数据类型的值，如果属性是引用数据类型，
			// 则复制的是栈内存地址而不是复制引用类型本身，新旧对象的引用类型则共享同一块内存，当一方的数据被修改时，另一方的数据同时也被修改，互相影响。
			// 克隆对象
			var obj = { username: 'kebe', age: 39 }
			// var clone1 = obj
			// console.log(clone1) // 结果是一个对象
			// clone1.age = 30
			// console.log(obj) // 给新变量赋值，原对象age的值被改变

			// 克隆数组
			var arr = [1, 3, { username: 'kebe' }]
			var arr1 = arr
			arr1[0] = 2
			arr1[2].username = '老王' // 结果和复制对象的结果是一样的
			console.log(arr, arr1)

			// 原理：复制基本数据类型的值只是按值传递，不会影响原变量的值

			// ------------------------------------------------------------------------------------------------------------------------------------------------

			// 浅克隆的方法
			// 第一种：直接赋值，跟上面的一样
			// 第二种：数组的slice方法 // 浅克隆
			// var arr2 = arr.slice()
			// // console.log(arr, arr2)
			// arr2[0] = 3
			// arr2[2].username = '老许'
			// console.log(arr, arr2)

			// // 第二种：数组的concat方法 // 浅克隆
			// arr3 = arr.concat()
			// console.log(arr, arr3)
			// arr3[0] = 3
			// arr3[2].username = '老曹'
			// console.log(arr, arr3)

			// // 第三种：Object.assign方法 // 浅克隆
			// var clone2 = Object.assign(obj)
			// console.log(obj, clone2)
			// clone2.username = '老陈'
			// console.log(obj, clone2)

			// // 第四种 JSON.parse(JSON.stringify(对象)) // 深克隆，不会影响原来的值
			// var json = JSON.parse(JSON.stringify(obj))
			// console.log(json, obj)
			// json.username = '老潘'
			// json.age = 80
			// console.log(json, obj)
			// 原理，是因为JSON.stringify(obj)对象经过转化为json字符串，数据类型经过改变，所以是复制基本值而不是引用
			// 缺点：无法拷贝functon，正则和undefined的类型数据
		</script>
	</body>
</html>
