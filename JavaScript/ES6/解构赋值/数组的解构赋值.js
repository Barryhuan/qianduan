// // 解构赋值是获取=号右边的数组或对象对左边的变量进行赋值的操作
// // Array的解构赋值
// // 基本形式：[] = ArrayObject

// // 1.基本的形式  ------------------------------------------------------------------------------------------------------------------------------

// let [a1, a2, a3] = [1, 2, 3]
// a1 // 1
// a2 // 2
// a3 // 3

// // 添加占位符
// let [, , a4] = [1, 2, 3]
// a4 // 3

// // 添加扩展符
let [, ...arr] = [1, 2, 3]
// ...arr === [2, 3]

// // 嵌套解构

// let [b1, [b2, b3], b4] = [1, [2, 3], 4]

// b1 // 1
// b2 // 2
// b3 // 3
// b4 // 4

// // 解构赋值分为完全解构，上面的示例都是完全解构 还有不完全解构， 失败解构

// // 不完全解构 ------------------------------------------------------------------------------------------------------------------------------

// let [c1, c2] = [1, 2, 3]
// c1 // 1
// c2 // 2


// let [e1, [e2], e4] = [1, [2, 3], 4]
// e1 // 1
// e2 // 2
// e4 // 4


// // 失败解构 ------------------------------------------------------------------------------------------------------------------------------

// let [d1, d2] = []
// d1 // undefined
// d2 // undefined

// // 数组解构不能从（普通对象）中获取，即使是拥有length属性的伪数组，因为普通对象本身不具有Interator接口
// // let [f1, f2, f3] = { 0: 0, 1: 1, 2: 2, length: 3}
// // console.log(f1, f2, f3) // 会出现TypeError

// // 但是可以解构函数的arguments对象
// // function aa () {
// //     return arguments
// // }

// // aa(1, 2, 3)

// // console.log(aa(1, 2, 3))

// // let [foo] = 123;
// // let [foo] = false;
// // let [foo] = NaN;
// // let [foo] = undefined;
// // let [foo] = null;
// // let [foo] = {};

// // 如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。
// // 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。



// // 2.set也可以通过数组解构出来 ----------------------------------------------------------------------------------------------------

// let [g1, g2, g3] = new Set([1, 2, 3])
// g1 // 1
// g2 // 2
// g3 // 3


// // 3.数组解构的默认值 ----------------------------------------------------------------------------------------------------

// // ES6 内部使用严格相等运算符（===），判断一个位置是否有值。
// // 只有当一个数组成员严格等于undefined，默认值才会生效，这是使用默认值的前提
// // 也就是当h或者h1 === undefined时，默认值才能生效
// let [h = 1] = [undefined]
// let [h1 = 1] = []

// h // 1
// h1 // 1

// // 当h2 严格不等于 undefined的时候，默认值就会被传入的值替换
// let [h2 = 1] = [2]
// h2 // 2


// // 默认值也可以是表达式

// function fun () {
//     return 'function'
// }

// let [h3 = fun()] = []
// h3 // function

// // 但是这种表达式是惰性表达式，同样遵守默认值的规则
// // 只要获取的数值中有值，这个表达式就不起作用

// let [h4 = fun()] = [1]
// h4 // 1


// // 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
// // let [x = 1, y = x] = [];     // x=1; y=1
// // let [x = 1, y = x] = [2];    // x=2; y=2
// // let [x = 1, y = x] = [1, 2]; // x=1; y=2
// // let [x = y, y = 1] = [];     // ReferenceError: y is not defined

// // 上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明



