// 解构赋值是获取=号右边的数组或对象对左边的变量进行赋值的操作
// Array的解构赋值
// 基本形式：[] = ArrayObject

// 1.基本的形式  ------------------------------------------------------------------------------------------------------------------------------

let [a1, a2, a3] = [1, 2, 3]
a1 // 1
a2 // 2
a3 // 3

// 添加占位符
let [, , a4] = [1, 2, 3]
a4 // 3

// // 添加扩展符
let [, ...arr] = [1, 2, 3]
// ...arr === [2, 3]

// 嵌套解构

let [b1, [b2, b3], b4] = [1, [2, 3], 4]

b1 // 1
b2 // 2
b3 // 3
b4 // 4

// 解构赋值分为完全解构，上面的示例都是完全解构 还有不完全解构， 失败解构

// 不完全解构 ------------------------------------------------------------------------------------------------------------------------------

let [c1, c2] = [1, 2, 3]
c1 // 1
c2 // 2


let [e1, [e2], e4] = [1, [2, 3], 4]
e1 // 1
e2 // 2
e4 // 4


// 失败解构 ------------------------------------------------------------------------------------------------------------------------------

let [d1, d2] = []
d1 // undefined
d2 // undefined

// 数组解构不能从（普通对象）中获取，即使是拥有length属性的伪数组，因为普通对象本身不具有Interator接口
// let [f1, f2, f3] = { 0: 0, 1: 1, 2: 2, length: 3}
// console.log(f1, f2, f3) // 会出现TypeError

// 但是可以解构函数的arguments对象
// function aa () {
//     return arguments
// }

// aa(1, 2, 3)

// console.log(aa(1, 2, 3))

// let [foo] = 123;
// let [foo] = false;
// let [foo] = NaN;
// let [foo] = undefined;
// let [foo] = null;
// let [foo] = {};

// 如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。
// 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。



// 2.set也可以通过数组解构出来 ----------------------------------------------------------------------------------------------------

let [g1, g2, g3] = new Set([1, 2, 3])
g1 // 1
g2 // 2
g3 // 3


// 3.数组解构的默认值 ----------------------------------------------------------------------------------------------------

// ES6 内部使用严格相等运算符（===），判断一个位置是否有值。
// 只有当一个数组成员严格等于undefined，默认值才会生效，这是使用默认值的前提
// 也就是当h或者h1 === undefined时，默认值才能生效
let [h = 1] = [undefined]
let [h1 = 1] = []

h // 1
h1 // 1

// 当h2 严格不等于 undefined的时候，默认值就会被传入的值替换
let [h2 = 1] = [2]
h2 // 2


// 默认值也可以是表达式

function fun () {
    return 'function'
}

let [h3 = fun()] = []
h3 // function

// 但是这种表达式是惰性表达式，同样遵守默认值的规则
// 只要获取的数值中有值，这个表达式就不起作用

let [h4 = fun()] = [1]
h4 // 1


// 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
// let [x = 1, y = x] = [];     // x=1; y=1
// let [x = 1, y = x] = [2];    // x=2; y=2
// let [x = 1, y = x] = [1, 2]; // x=1; y=2
// let [x = y, y = 1] = [];     // ReferenceError: y is not defined

// 上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明



